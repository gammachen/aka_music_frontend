<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>机器学习核心概念详解</title>
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 50px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin-bottom: 40px;
            position: relative;
        }

        .screenshot-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000;
            font-size: 16px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        .screenshot-btn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .concept-section {
            background: white;
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        h2 {
            font-size: 1.8em;
            color: #4a5568;
            margin-bottom: 20px;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }

        h3 {
            font-size: 1.4em;
            color: #2d3748;
            margin: 20px 0 10px;
        }

        p {
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        code {
            font-family: 'Courier New', Courier, monospace;
        }

        pre {
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
        }

        ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .code-block {
            background: #282c34;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 20px 0;
        }

        .math-block {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            text-align: center;
        }

        .highlight {
            background-color: #f0f7ff;
            padding: 15px;
            border-left: 4px solid #3182ce;
            margin: 20px 0;
        }

        blockquote {
            background: #f9f9f9;
            border-left: 5px solid #6b7280;
            margin: 20px 0;
            padding: 15px;
            font-style: italic;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div class="loading-text">正在生成截图...</div>
    </div>
    
    <button class="screenshot-btn" onclick="captureScreenshots()">保存为图片</button>

    <header>
        <div class="container">
            <h1>机器学习核心概念详解</h1>
            <p>技术解析与代码实现</p>
        </div>
    </header>

    <div class="container" id="content">
        <!-- 模型 -->
        <section class="concept-section" id="model">
            <h2>1. 模型（Model）</h2>
            <p><strong>定义</strong>：从数据中学习到的输入到输出的映射函数</p>
            <div class="math-block">
                <span class="katex-render">( hat{y} = f_theta(x) )</span>
            </div>
            <p><strong>示例</strong>：</p>
            <ul>
                <li>房价预测模型：( hat{price} = 0.8 times area + 50 times age + 100 )</li>
                <li>图像分类模型：ResNet50神经网络</li>
            </ul>
            <h3>代码实现</h3>
            <div class="code-block">
                <pre><code class="language-python">
# PyTorch模型定义示例
import torch.nn as nn
class LinearModel(nn.Module):
    def __init__(self):
        super().__init__()
        self.linear = nn.Linear(3, 1)  # 输入3维，输出1维
        
    def forward(self, x):
        return self.linear(x)
                </code></pre>
            </div>
        </section>

        <!-- 误差/损失 -->
        <section class="concept-section" id="loss">
            <h2>2. 误差/损失（Loss）</h2>
            <p><strong>数学定义</strong>：量化预测值与真实值的差异</p>
            <div class="highlight">
                <table>
                    <thead>
                        <tr>
                            <th>任务类型</th>
                            <th>损失函数</th>
                            <th>公式</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>回归</td>
                            <td>均方误差（MSE）</td>
                            <td>( frac{1}{n}sum(y-hat{y})^2 )</td>
                        </tr>
                        <tr>
                            <td>分类</td>
                            <td>交叉熵损失</td>
                            <td>( -sum ylog(hat{y}) )</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h3>代码计算</h3>
            <div class="code-block">
                <pre><code class="language-python">
import torch
y_true = torch.tensor([1.0, 2.0])
y_pred = torch.tensor([1.5, 1.8])

# MSE计算
mse_loss = torch.mean((y_true - y_pred)**2)  # 输出: 0.145
                </code></pre>
            </div>
        </section>

        <!-- 预测值 -->
        <section class="concept-section" id="prediction">
            <h2>3. 预测值（Prediction）</h2>
            <p><strong>定义</strong>：模型对输入样本的输出结果</p>
            <p><strong>示例</strong>：</p>
            <ul>
                <li>垃圾邮件分类器输出：spam_prob=0.93</li>
                <li>温度预测模型输出：28.5℃</li>
            </ul>
            <h3>代码获取</h3>
            <div class="code-block">
                <pre><code class="language-python">
from sklearn.linear_model import LogisticRegression

model = LogisticRegression().fit(X_train, y_train)
prob = model.predict_proba([[5.1, 3.5]])  # 输出概率分布
                </code></pre>
            </div>
        </section>

        <!-- 模型训练 -->
        <section class="concept-section" id="training">
            <h2>4. 模型训练（Training）</h2>
            <p><strong>核心过程</strong>：通过优化算法调整参数θ最小化损失</p>
            <div class="math-block">
                <span class="katex-render">( theta_{t+1} = theta_t - eta nabla_theta L(theta) )</span>
            </div>
            <h3>训练代码</h3>
            <div class="code-block">
                <pre><code class="language-python">
# 神经网络训练循环示例
optimizer = torch.optim.SGD(model.parameters(), lr=0.01)

for epoch in range(100):
    # 前向传播
    outputs = model(inputs)
    loss = criterion(outputs, labels)
    
    # 反向传播
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()
                </code></pre>
            </div>
        </section>

        <!-- 模型收敛 -->
        <section class="concept-section" id="convergence">
            <h2>5. 模型收敛（Convergence）</h2>
            <p><strong>定义</strong>：当训练损失不再显著下降时达到稳定状态</p>
            <h3>可视化分析</h3>
            <div class="code-block">
                <pre><code class="language-python">
import matplotlib.pyplot as plt
plt.plot(train_losses, label='Training Loss')
plt.plot(val_losses, label='Validation Loss')
plt.title('Loss Convergence Curve')
plt.legend()
                </code></pre>
            </div>
        </section>

        <!-- 模型评估 -->
        <section class="concept-section" id="evaluation">
            <h2>6. 模型评估（Evaluation）</h2>
            <div class="highlight">
                <table>
                    <thead>
                        <tr>
                            <th>任务类型</th>
                            <th>评估指标</th>
                            <th>公式</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>分类</td>
                            <td>F1-Score</td>
                            <td>( frac{2 times P times R}{P + R} )</td>
                        </tr>
                        <tr>
                            <td>回归</td>
                            <td>R² Score</td>
                            <td>( 1 - frac{sum(y-hat{y})^2}{sum(y-bar{y})^2} )</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h3>代码实现</h3>
            <div class="code-block">
                <pre><code class="language-python">
from sklearn.metrics import confusion_matrix

# 混淆矩阵示例
y_true = [1,0,1,1,0]
y_pred = [1,0,0,1,0]
print(confusion_matrix(y_true, y_pred)) 
# 输出：[[2 0],
#       [1 2]]
                </code></pre>
            </div>
        </section>

        <!-- 模型推理/预测 -->
        <section class="concept-section" id="inference">
            <h2>7. 模型推理/预测（Inference）</h2>
            <p><strong>定义</strong>：使用训练好的模型对新数据生成预测</p>
            <h3>部署代码</h3>
            <div class="code-block">
                <pre><code class="language-python">
# ONNX格式跨平台推理示例
import onnxruntime as ort

ort_session = ort.InferenceSession("model.onnx")
inputs = {"input": input_data.astype(np.float32)}
outputs = ort_session.run(None, inputs)
                </code></pre>
            </div>
        </section>

        <!-- 模型部署 -->
        <section class="concept-section" id="deployment">
            <h2>8. 模型部署（Deployment）</h2>
            <div class="highlight">
                <table>
                    <thead>
                        <tr>
                            <th>部署场景</th>
                            <th>技术方案</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>云端服务</td>
                            <td>Flask + Docker</td>
                        </tr>
                        <tr>
                            <td>移动端</td>
                            <td>TensorFlow Lite</td>
                        </tr>
                        <tr>
                            <td>边缘设备</td>
                            <td>ONNX Runtime</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h3>REST API示例</h3>
            <div class="code-block">
                <pre><code class="language-python">
from flask import Flask, request
import joblib

app = Flask(__name__)
model = joblib.load('model.pkl')

@app.route('/predict', methods=['POST'])
def predict():
    data = request.json
    return {'prediction': float(model.predict([data['features']])[0])}
                </code></pre>
            </div>
        </section>

        <!-- 核心概念关系图 -->
        <section class="concept-section" id="concept-map">
            <h2>核心概念关系图</h2>
            <blockquote>
                <p>[原始数据] → [特征工程] → [模型训练] → [评估优化]</p>
                <p>↓</p>
                <p>[模型部署] → [在线推理]</p>
            </blockquote>
        </section>

        <!-- 技术要点总结 -->
        <section class="concept-section" id="summary">
            <h2>技术要点总结</h2>
            <ul>
                <li><strong>模型即函数</strong>：参数化映射关系的数学表达</li>
                <li><strong>损失函数是导航仪</strong>：指导参数优化方向</li>
                <li><strong>评估指标需对齐业务目标</strong>：分类准确率≠商业价值</li>
                <li><strong>部署是系统工程</strong>：需考虑吞吐量、延迟、可维护性</li>
            </ul>
            <blockquote>
                <p>建议在PPT中增加：梯度下降动态示意图（小球滚落至谷底）、混淆矩阵热力图可视化、模型部署架构图（展示从训练到服务的完整流水线）、关键数学公式用不同颜色标注变量含义（如红色标出学习率η）</p>
            </blockquote>
        </section>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.katex-render').forEach(block => {
                try {
                    const formula = block.textContent.trim();
                    katex.render(formula, block, {
                        throwOnError: false,
                        displayMode: true
                    });
                } catch (e) {
                    console.error("KaTeX error:", e);
                }
            });
        });

        // 截图功能
        async function captureScreenshots() {
            const loading = document.getElementById('loading');
            loading.style.display = 'flex';

            try {
                const content = document.getElementById('content');
                const sections = content.getElementsByClassName('concept-section');
                let index = 1;

                for (let section of sections) {
                    const canvas = await html2canvas(section, {
                        scale: 2,
                        logging: false,
                        useCORS: true
                    });

                    // 创建下载链接
                    const link = document.createElement('a');
                    link.download = `ml-conception-${index}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    index++;

                    // 等待一小段时间再继续下一张截图
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                alert('截图已完成！');
            } catch (error) {
                console.error('截图过程出错：', error);
                alert('截图过程出现错误，请查看控制台了解详情。');
            } finally {
                loading.style.display = 'none';
            }
        }
    </script>
</body>
</html> 