<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>反欺诈知识图谱示例</title>
    <style>
        pre { background-color: #f4f4f4; padding: 15px; }
        .plot { margin: 20px; }
        .terminal { 
            background-color: #1e1e1e; 
            color: #f0f0f0; 
            padding: 15px; 
            border-radius: 5px; 
            font-family: 'Courier New', monospace;
            line-height: 1.5;
            white-space: pre-wrap;
            height: 400px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .typed-cursor {
            color: #f0f0f0;
        }
    </style>
    <script src="/js/typed.umd.js"></script>
</head>
<body>
    <h2>反欺诈知识图谱代码实现</h2>

    <!-- 代码部分 -->
    <div class="terminal">
        <!-- 隐藏原始代码内容，但保留结构以便JS获取 -->
        <div id="typed-strings" style="display: none;">
            <p>
        # 依赖库：pip install pandas matplotlib torch torch-geometric neo4j torch-cluster networkx
# 注意：Node2Vec需要额外安装torch-cluster包：pip install torch-cluster
# 或者：pip install pyg-lib torch-scatter torch-sparse torch-cluster torch-spline-conv torch-geometric -f https://data.pyg.org/whl/torch-${TORCH_VERSION}.html

import pandas as pd
import matplotlib.pyplot as plt
import torch
import numpy as np
from neo4j import GraphDatabase
from torch_geometric.utils import from_networkx
import networkx as nx
from datetime import datetime, timedelta
import random

# Neo4j连接配置
NEO4J_URI = "bolt://127.0.0.1:7687"  # 默认Neo4j连接URI
NEO4J_USER = "neo4j"                # 默认用户名
NEO4J_PASSWORD = "neo4j"         # 默认密码，实际使用时应修改

# 创建Neo4j驱动
driver = GraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USER, NEO4J_PASSWORD))

# === 1. 模拟金融欺诈环数据生成 ===

# 生成随机日期
def random_date(start_date, end_date):
    time_between_dates = end_date - start_date
    days_between_dates = time_between_dates.days
    random_number_of_days = random.randrange(days_between_dates)
    return start_date + timedelta(days=random_number_of_days)

# 生成随机金额
def random_amount():
    # 大部分是小额交易，少量大额交易
    if random.random() < 0.8:
        return round(random.uniform(10, 1000), 2)
    else:
        return round(random.uniform(1000, 10000), 2)

# 生成欺诈环的账户和交易
def generate_fraud_ring_data(num_accounts=100, num_merchants=20, num_transactions=500):
    # 生成账户
    accounts = [f"ACC_{i:06d}" for i in range(num_accounts)]
    
    # 生成商户
    merchants = [f"MERCH_{i:04d}" for i in range(num_merchants)]
    
    # 生成银行
    banks = ["Bank_A", "Bank_B", "Bank_C", "Bank_D", "Bank_E"]
    
    # 生成地区
    regions = ["Beijing", "Shanghai", "Guangzhou", "Shenzhen", "Hangzhou", "Chengdu", "Wuhan"]
    
    # 为账户分配银行和地区
    account_info = {}
    for acc in accounts:
        account_info[acc] = {
            "bank": random.choice(banks),
            "region": random.choice(regions),
            "is_fraud_ring": False  # 默认不是欺诈环的一部分
        }
    
    # 为商户分配地区
    merchant_info = {}
    for merch in merchants:
        merchant_info[merch] = {
            "region": random.choice(regions),
            "is_fraud_ring": False  # 默认不是欺诈环的一部分
        }
    
    # 创建欺诈环 - 选择一些账户和商户形成环状交易模式
    # 欺诈环1：8个账户之间形成环状交易
    fraud_ring1 = random.sample(accounts, 8)
    for acc in fraud_ring1:
        account_info[acc]["is_fraud_ring"] = True
    
    # 欺诈环2：5个账户和3个商户之间形成环状交易
    fraud_ring2_accounts = random.sample([acc for acc in accounts if acc not in fraud_ring1], 5)
    fraud_ring2_merchants = random.sample(merchants, 3)
    
    for acc in fraud_ring2_accounts:
        account_info[acc]["is_fraud_ring"] = True
    
    for merch in fraud_ring2_merchants:
        merchant_info[merch]["is_fraud_ring"] = True
    
    # 生成交易数据
    transactions = []
    start_date = datetime(2023, 1, 1)
    end_date = datetime(2023, 12, 31)
    
    # 生成正常交易
    for _ in range(num_transactions - 50):  # 预留50个交易用于欺诈环
        from_account = random.choice(accounts)
        # 70%的交易是账户到商户，30%是账户到账户
        if random.random() < 0.7:
            to_entity = random.choice(merchants)
            to_type = "merchant"
        else:
            # 确保不是自己转给自己
            to_entity = random.choice([acc for acc in accounts if acc != from_account])
            to_type = "account"
        
        transactions.append({
            "from_account": from_account,
            "to_entity": to_entity,
            "to_type": to_type,
            "amount": random_amount(),
            "date": random_date(start_date, end_date),
            "is_fraud": False
        })
    
    # 生成欺诈环1的交易 - 账户之间形成环
    for i in range(len(fraud_ring1)):
        from_account = fraud_ring1[i]
        to_account = fraud_ring1[(i+1) % len(fraud_ring1)]  # 形成环
        
        # 为每对账户生成多笔小额交易
        for _ in range(5):  # 每对账户5笔交易
            transactions.append({
                "from_account": from_account,
                "to_entity": to_account,
                "to_type": "account",
                "amount": round(random.uniform(100, 500), 2),  # 小额交易
                "date": random_date(start_date, end_date),
                "is_fraud": True
            })
    
    # 生成欺诈环2的交易 - 账户和商户之间形成环
    # 账户 -> 商户 -> 账户 -> 商户 -> 账户 (形成环)
    ring2_entities = fraud_ring2_accounts + fraud_ring2_merchants
    for i in range(len(ring2_entities)):
        from_entity = ring2_entities[i]
        to_entity = ring2_entities[(i+1) % len(ring2_entities)]
        
        # 确定实体类型
        from_type = "account" if from_entity.startswith("ACC") else "merchant"
        to_type = "account" if to_entity.startswith("ACC") else "merchant"
        
        # 只处理有效的交易方向：账户->账户，账户->商户
        if from_type == "account":
            for _ in range(5):  # 每对实体5笔交易
                transactions.append({
                    "from_account": from_entity,
                    "to_entity": to_entity,
                    "to_type": to_type,
                    "amount": round(random.uniform(200, 800), 2),
                    "date": random_date(start_date, end_date),
                    "is_fraud": True
                })
    
    # 转换为DataFrame
    df_transactions = pd.DataFrame(transactions)
    
    # 创建账户信息DataFrame
    accounts_data = []
    for acc, info in account_info.items():
        accounts_data.append({
            "account_id": acc,
            "bank": info["bank"],
            "region": info["region"],
            "is_fraud_ring": info["is_fraud_ring"]
        })
    df_accounts = pd.DataFrame(accounts_data)
    
    # 创建商户信息DataFrame
    merchants_data = []
    for merch, info in merchant_info.items():
        merchants_data.append({
            "merchant_id": merch,
            "region": info["region"],
            "is_fraud_ring": info["is_fraud_ring"]
        })
    df_merchants = pd.DataFrame(merchants_data)
    
    return df_transactions, df_accounts, df_merchants

# 生成数据
df_transactions, df_accounts, df_merchants = generate_fraud_ring_data()

# 打印数据统计信息
print("\n交易数据统计:")
print(f"总交易数: {len(df_transactions)}")
print(f"欺诈交易数: {df_transactions['is_fraud'].sum()}")
print(f"账户总数: {len(df_accounts)}")
print(f"欺诈环账户数: {df_accounts['is_fraud_ring'].sum()}")
print(f"商户总数: {len(df_merchants)}")
print(f"欺诈环商户数: {df_merchants['is_fraud_ring'].sum()}")

# 打印欺诈环账户
fraud_accounts = df_accounts[df_accounts['is_fraud_ring']]['account_id'].tolist()
print("\n欺诈环账户:")
for acc in fraud_accounts:
    print(acc)

# 打印欺诈环商户
fraud_merchants = df_merchants[df_merchants['is_fraud_ring']]['merchant_id'].tolist()
print("\n欺诈环商户:")
for merch in fraud_merchants:
    print(merch)

PREFIX = "FR_"  # Fraud Ring前缀
# === 2. 构建知识图谱（Neo4j版本）===
def create_graph():
    # 添加前缀，避免删除现有数据
    # PREFIX = "FR_"  # Fraud Ring前缀
    
    with driver.session() as session:
        # 只删除我们指定的实体和关系，不影响其他数据
        session.run(f"""MATCH (n) 
                     WHERE n:{PREFIX}Account OR n:{PREFIX}Merchant OR n:{PREFIX}Bank OR n:{PREFIX}Region 
                     DETACH DELETE n""")
        
        # 创建唯一性约束（确保节点唯一）
        session.run(f"CREATE CONSTRAINT IF NOT EXISTS FOR (a:{PREFIX}Account) REQUIRE a.id IS UNIQUE")
        session.run(f"CREATE CONSTRAINT IF NOT EXISTS FOR (m:{PREFIX}Merchant) REQUIRE m.id IS UNIQUE")
        session.run(f"CREATE CONSTRAINT IF NOT EXISTS FOR (b:{PREFIX}Bank) REQUIRE b.name IS UNIQUE")
        session.run(f"CREATE CONSTRAINT IF NOT EXISTS FOR (r:{PREFIX}Region) REQUIRE r.name IS UNIQUE")
        
        # 创建账户节点
        for _, row in df_accounts.iterrows():
            session.run(f"""
                MERGE (a:{PREFIX}Account {{id: $account_id}})
                SET a.bank = $bank,
                    a.region = $region,
                    a.is_fraud_ring = $is_fraud_ring,
                    a.type = 'account',
                    a.name = $account_id
            """, account_id=row['account_id'], bank=row['bank'], 
                 region=row['region'], is_fraud_ring=row['is_fraud_ring'])
        
        # 创建商户节点
        for _, row in df_merchants.iterrows():
            session.run(f"""
                MERGE (m:{PREFIX}Merchant {{id: $merchant_id}})
                SET m.region = $region,
                    m.is_fraud_ring = $is_fraud_ring,
                    m.type = 'merchant',
                    m.name = $merchant_id
            """, merchant_id=row['merchant_id'], region=row['region'], 
                 is_fraud_ring=row['is_fraud_ring'])
        
        # 创建银行节点
        for bank in df_accounts['bank'].unique():
            session.run(f"""
                MERGE (b:{PREFIX}Bank {{name: $bank}})
                SET b.type = 'bank'
            """, bank=bank)
        
        # 创建地区节点
        all_regions = set(df_accounts['region'].unique()) | set(df_merchants['region'].unique())
        for region in all_regions:
            session.run(f"""
                MERGE (r:{PREFIX}Region {{name: $region}})
                SET r.type = 'region'
            """, region=region)
        
        # 创建关系：账户-银行
        for _, row in df_accounts.iterrows():
            session.run(f"""
                MATCH (a:{PREFIX}Account {{id: $account_id}})
                MATCH (b:{PREFIX}Bank {{name: $bank}})
                MERGE (a)-[:{PREFIX}BELONGS_TO]->(b)
            """, account_id=row['account_id'], bank=row['bank'])
        
        # 创建关系：账户-地区
        for _, row in df_accounts.iterrows():
            session.run(f"""
                MATCH (a:{PREFIX}Account {{id: $account_id}})
                MATCH (r:{PREFIX}Region {{name: $region}})
                MERGE (a)-[:{PREFIX}LOCATED_IN]->(r)
            """, account_id=row['account_id'], region=row['region'])
        
        # 创建关系：商户-地区
        for _, row in df_merchants.iterrows():
            session.run(f"""
                MATCH (m:{PREFIX}Merchant {{id: $merchant_id}})
                MATCH (r:{PREFIX}Region {{name: $region}})
                MERGE (m)-[:{PREFIX}LOCATED_IN]->(r)
            """, merchant_id=row['merchant_id'], region=row['region'])
        
        # 创建交易关系
        for _, row in df_transactions.iterrows():
            # 处理账户到账户的交易
            if row['to_type'] == 'account':
                session.run(f"""
                    MATCH (from:{PREFIX}Account {{id: $from_account}})
                    MATCH (to:{PREFIX}Account {{id: $to_entity}})
                    CREATE (from)-[t:{PREFIX}TRANSFERS {{amount: $amount, date: $date, is_fraud: $is_fraud}}]->(to)
                """, from_account=row['from_account'], to_entity=row['to_entity'],
                     amount=row['amount'], date=str(row['date']), is_fraud=row['is_fraud'])
            # 处理账户到商户的交易
            elif row['to_type'] == 'merchant':
                session.run(f"""
                    MATCH (from:{PREFIX}Account {{id: $from_account}})
                    MATCH (to:{PREFIX}Merchant {{id: $to_entity}})
                    CREATE (from)-[t:{PREFIX}PAYS {{amount: $amount, date: $date, is_fraud: $is_fraud}}]->(to)
                """, from_account=row['from_account'], to_entity=row['to_entity'],
                     amount=row['amount'], date=str(row['date']), is_fraud=row['is_fraud'])

# 执行图谱创建
create_graph()

# === 3. PageRank识别中心节点（Neo4j版本）===
def get_high_risk_nodes():
    # 使用与create_graph相同的前缀
    # PREFIX = "FR_"
    
    with driver.session() as session:
        try:
            # 使用Neo4j的内置PageRank算法
            session.run(f"""
                CALL gds.graph.project(
                    'fraudGraph',
                    ['{PREFIX}Account', '{PREFIX}Merchant', '{PREFIX}Bank', '{PREFIX}Region'],
                    ['{PREFIX}TRANSFERS', '{PREFIX}PAYS', '{PREFIX}BELONGS_TO', '{PREFIX}LOCATED_IN']
                )
            """)
            
            # 运行PageRank算法
            result = session.run("""
                CALL gds.pageRank.stream('fraudGraph')
                YIELD nodeId, score
                WITH gds.util.asNode(nodeId) AS node, score
                RETURN node.name AS name, labels(node)[0] AS type, node.is_fraud_ring AS is_fraud_ring, score
                ORDER BY score DESC
                LIMIT 10
            """)
            
            # 获取结果
            high_risk_nodes = [(record["name"], record["type"].replace(PREFIX, "").lower(), 
                              record["is_fraud_ring"], record["score"]) for record in result]
            
            # 删除投影图
            session.run("CALL gds.graph.drop('fraudGraph')")
            
            return high_risk_nodes
        except Exception as e:
            print(f"Neo4j PageRank执行失败: {e}")
            return None

# 尝试获取高风险节点
high_risk_nodes = get_high_risk_nodes()

if high_risk_nodes:
    print("\n高风险节点（Neo4j PageRank Top 10）:")
    for node, node_type, is_fraud, score in high_risk_nodes:
        fraud_status = "(欺诈环成员)" if is_fraud else ""
        print(f"{node} ({node_type}) {fraud_status}: {score:.4f}")
else:
    print("使用替代方案：从Neo4j导出到NetworkX计算PageRank")
    
    # 从Neo4j导出数据到NetworkX
    G = nx.DiGraph()  # 有向图，因为资金流动有方向
    # PREFIX = "FR_"  # 使用与create_graph相同的前缀
    
    with driver.session() as session:
        # 获取所有节点
        nodes_result = session.run(f"""
            MATCH (n)
            WHERE n:{PREFIX}Account OR n:{PREFIX}Merchant OR n:{PREFIX}Bank OR n:{PREFIX}Region
            RETURN n.id AS id, n.name AS name, labels(n)[0] AS type, n.is_fraud_ring AS is_fraud_ring
        """)
        
        for record in nodes_result:
            node_id = record["id"] if record["id"] is not None else record["name"]
            if node_id is not None:
                node_type = record["type"].replace(PREFIX, "").lower() if record["type"] is not None else "unknown"
                G.add_node(node_id, name=record["name"], type=node_type, is_fraud_ring=record["is_fraud_ring"])
        
        # 获取所有关系
        edges_result = session.run(f"""
            MATCH (a)-[r]->(b)
            WHERE (a:{PREFIX}Account OR a:{PREFIX}Merchant OR a:{PREFIX}Bank OR a:{PREFIX}Region) 
            AND (b:{PREFIX}Account OR b:{PREFIX}Merchant OR b:{PREFIX}Bank OR b:{PREFIX}Region)
            RETURN a.id AS source_id, a.name AS source_name, 
                   b.id AS target_id, b.name AS target_name, 
                   type(r) AS relation, r.amount AS amount
        """)
        
        for record in edges_result:
            source_id = record["source_id"] if record["source_id"] is not None else record["source_name"]
            target_id = record["target_id"] if record["target_id"] is not None else record["target_name"]
            
            if source_id is not None and target_id is not None:
                relation = record["relation"].replace(PREFIX, "").lower() if record["relation"] is not None else "unknown"
                weight = 1.0  # 默认权重
                if record["amount"] is not None:
                    # 金额越大，权重越小（小额频繁交易更可疑）
                    weight = 1.0 / (1.0 + record["amount"] / 1000.0)
                G.add_edge(source_id, target_id, relation=relation, weight=weight)
    
    # 使用NetworkX计算PageRank，添加参数以获得更好的结果
    pagerank = nx.pagerank(G, alpha=0.85, max_iter=100, tol=1e-6, weight='weight')
    
    # 过滤掉可能的None节点
    pagerank = {k: v for k, v in pagerank.items() if k is not None}
    
    # 获取高风险节点
    high_risk_nodes = sorted(pagerank.items(), key=lambda x: -x[1])[:10]
    
    print("\n高风险节点（NetworkX PageRank Top 10）:")
    for node_id, score in high_risk_nodes:
        node_data = G.nodes[node_id]
        node_name = node_data.get("name", node_id)
        node_type = node_data.get("type", "unknown")
        is_fraud = node_data.get("is_fraud_ring", False)
        fraud_status = "(欺诈环成员)" if is_fraud else ""
        print(f"{node_name} ({node_type}) {fraud_status}: {score:.4f}")



# === 4. 循环检测算法（识别欺诈环）===
def detect_fraud_rings():
    # PREFIX = "FR_"  # 使用与create_graph相同的前缀
    
    with driver.session() as session:
        try:
            # 创建图投影，只包含账户和交易关系
            session.run(f"""
                CALL gds.graph.project(
                    'cycleGraph',
                    ['{PREFIX}Account', '{PREFIX}Merchant'],
                    {{
                        {PREFIX}TRANSFERS: {{
                            orientation: 'NATURAL'
                        }},
                        {PREFIX}PAYS: {{
                            orientation: 'NATURAL'
                        }}
                    }}
                )
            """)
            
            # 运行循环检测算法
            result = session.run("""
                CALL gds.alpha.cycles.stream('cycleGraph')
                YIELD nodeIds
                WITH [nodeId IN nodeIds | gds.util.asNode(nodeId)] AS cycle_nodes
                WHERE size(cycle_nodes) >= 3 AND size(cycle_nodes) <= 10
                RETURN cycle_nodes, size(cycle_nodes) AS cycle_size
                ORDER BY cycle_size
            """)
            
            # 获取结果
            cycles = []
            for record in result:
                cycle = []
                for node in record["cycle_nodes"]:
                    cycle.append((node["name"], node.get("type", "unknown")))
                cycles.append((cycle, record["cycle_size"]))
            
            # 删除投影图
            session.run("CALL gds.graph.drop('cycleGraph')")
            
            return cycles
        except Exception as e:
            print(f"Neo4j循环检测执行失败: {e}")
            print("使用NetworkX替代方案进行循环检测...")
            return detect_fraud_rings_networkx()

# NetworkX替代方案：循环检测
def detect_fraud_rings_networkx():
    # 从Neo4j导出数据到NetworkX
    G = nx.DiGraph()  # 有向图，因为资金流动有方向
    # PREFIX = "FR_"  # 使用与create_graph相同的前缀
    
    with driver.session() as session:
        # 获取所有节点（包括账户、商户、银行和地区）
        nodes_result = session.run(f"""
            MATCH (n)
            WHERE n:{PREFIX}Account OR n:{PREFIX}Merchant OR n:{PREFIX}Bank OR n:{PREFIX}Region
            RETURN n.id AS id, n.name AS name, labels(n)[0] AS type, n.is_fraud_ring AS is_fraud_ring
        """)
        
        for record in nodes_result:
            if record["id"] is not None:
                G.add_node(record["id"], name=record["name"], 
                          type=record["type"].replace(PREFIX, "").lower(),
                          is_fraud_ring=record["is_fraud_ring"])
        
        # 获取所有关系（包括交易、归属和位置关系）
        edges_result = session.run(f"""
            MATCH (a)-[r:{PREFIX}TRANSFERS|{PREFIX}PAYS|{PREFIX}BELONGS_TO|{PREFIX}LOCATED_IN]->(b)
            RETURN a.id AS source, b.id AS target, type(r) AS relation, r.amount AS amount
        """)
        
        for record in edges_result:
            if record["source"] is not None and record["target"] is not None:
                relation = record["relation"].replace(PREFIX, "").lower()
                G.add_edge(record["source"], record["target"], 
                          relation=relation, amount=record["amount"])
    
    # 查找所有简单环路（长度3-10）
    cycles = []
    for cycle in nx.simple_cycles(G):
        if 3 <= len(cycle) <= 10:  # 只关注3-10个节点的环
            cycle_nodes = []
            for node_id in cycle:
                node_data = G.nodes[node_id]
                cycle_nodes.append((node_data.get("name", node_id), 
                                  node_data.get("type", "unknown")))
            cycles.append((cycle_nodes, len(cycle)))
    
    # 按环的大小排序
    cycles.sort(key=lambda x: x[1])
    return cycles

# 尝试检测欺诈环
try:
    print("\n检测欺诈环...")
    cycles = detect_fraud_rings()
    
    if cycles:
        print(f"\n检测到 {len(cycles)} 个可能的欺诈环:")
        for i, (cycle, size) in enumerate(cycles[:5]):  # 只显示前5个
            print(f"\n欺诈环 #{i+1} (节点数: {size}):")
            for node, node_type in cycle:
                print(f"  - {node} ({node_type})")
        
        # 可视化欺诈环
        print("\n绘制欺诈环网络图...")
        # 创建一个有向图用于可视化
        G_viz = nx.DiGraph()
        
        # 添加欺诈环的节点和边
        for cycle, _ in cycles[:3]:  # 只可视化前3个欺诈环
            for i in range(len(cycle)):
                node, node_type = cycle[i]
                next_node, next_node_type = cycle[(i+1) % len(cycle)]
                
                # 添加节点
                if node not in G_viz:
                    G_viz.add_node(node, type=node_type, is_fraud_ring=True)
                if next_node not in G_viz:
                    G_viz.add_node(next_node, type=next_node_type, is_fraud_ring=True)
                
                # 添加边
                G_viz.add_edge(node, next_node, is_fraud=True)
        
        # 从Neo4j获取相关的银行和地区节点
        with driver.session() as session:
            # 获取与欺诈环账户相关的银行
            bank_result = session.run(f"""
                MATCH (a:{PREFIX}Account)-[:{PREFIX}BELONGS_TO]->(b:{PREFIX}Bank)
                WHERE a.name IN $account_nodes
                RETURN a.name AS account, b.name AS bank
            """, account_nodes=[node for node, _ in G_viz.nodes(data=True) if G_viz.nodes[node].get('type') == 'account'])
            
            # 添加银行节点和关系
            for record in bank_result:
                account = record["account"]
                bank = record["bank"]
                if bank not in G_viz:
                    G_viz.add_node(bank, type='bank', is_fraud_ring=False)
                G_viz.add_edge(account, bank, relation='belongs_to', is_fraud=False)
            
            # 获取与欺诈环账户和商户相关的地区
            region_result = session.run(f"""
                MATCH (n)-[:{PREFIX}LOCATED_IN]->(r:{PREFIX}Region)
                WHERE n.name IN $nodes
                RETURN n.name AS node, r.name AS region
            """, nodes=[node for node, _ in G_viz.nodes(data=True)])
            
            # 添加地区节点和关系
            for record in region_result:
                node = record["node"]
                region = record["region"]
                if region not in G_viz:
                    G_viz.add_node(region, type='region', is_fraud_ring=False)
                G_viz.add_edge(node, region, relation='located_in', is_fraud=False)
        
        # 为不同类型的节点设置颜色
        color_map = {
            'account': '#6495ED',  # 蓝色
            'merchant': '#F08080',  # 红色
            'bank': '#90EE90',      # 绿色
            'region': '#DDA0DD'     # 紫色
        }
        
        # 获取节点颜色和大小
        node_colors = []
        node_sizes = []
        for node in G_viz.nodes():
            node_type = G_viz.nodes[node].get('type', 'unknown').lower()
            node_colors.append(color_map.get(node_type, 'gray'))
            
            # 根据节点类型设置不同大小
            if node_type == 'account':
                node_sizes.append(800)  # 账户节点
            elif node_type == 'merchant':
                node_sizes.append(1000)  # 商户节点
            elif node_type == 'bank':
                node_sizes.append(1200)  # 银行节点
            elif node_type == 'region':
                node_sizes.append(1400)  # 地区节点
            else:
                node_sizes.append(600)  # 其他节点
        
        # 获取边颜色和样式
        edge_colors = []
        edge_styles = []
        for edge in G_viz.edges():
            if G_viz.edges[edge].get('is_fraud', False):
                edge_colors.append('red')
                edge_styles.append('solid')
            elif G_viz.edges[edge].get('relation') == 'belongs_to':
                edge_colors.append('green')
                edge_styles.append('dashed')
            elif G_viz.edges[edge].get('relation') == 'located_in':
                edge_colors.append('purple')
                edge_styles.append('dotted')
            else:
                edge_colors.append('gray')
                edge_styles.append('solid')
        
        # 创建图形
        plt.figure(figsize=(16, 12))
        
        # 使用spring布局，增加k值使节点分布更开
        pos = nx.spring_layout(G_viz, k=0.4, iterations=100, seed=42)
        
        # 绘制网络
        nx.draw(G_viz, 
                pos=pos,
                with_labels=True, 
                node_color=node_colors,
                node_size=node_sizes,
                font_size=9,
                font_weight='bold',
                edge_color=edge_colors,
                style=edge_styles,
                width=1.5,
                alpha=0.9,
                arrows=True,
                arrowsize=15)
        
        # 添加图例
        legend_elements = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=color, markersize=10, label=node_type)
                          for node_type, color in color_map.items()]
        plt.legend(handles=legend_elements, loc='upper right')
        
        plt.title("欺诈环网络结构", fontsize=16)
        plt.tight_layout()
        
        # 获取当前时间并格式化为字符串
        from datetime import datetime
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # 保存为高分辨率图片
        plt.savefig(f'fraud_ring_network_{timestamp}.png', dpi=300)
        print(f"网络图已保存为: fraud_ring_network_{timestamp}.png")
    else:
        print("未检测到欺诈环")
except Exception as e:
    print(f"欺诈环检测失败: {e}")

# === 5. 图嵌入（Node2Vec）实现 ===
# 从Neo4j导出数据到NetworkX用于图嵌入
G_for_embedding = nx.DiGraph()  # 使用有向图

with driver.session() as session:
    # 使用与create_graph相同的前缀
    # PREFIX = "FR_"  # Fraud Ring前缀
    
    # 获取所有节点（包括账户、商户、银行和地区）
    nodes_result = session.run(f"""
        MATCH (n)
        WHERE n:{PREFIX}Account OR n:{PREFIX}Merchant OR n:{PREFIX}Bank OR n:{PREFIX}Region
        RETURN n.id AS id, n.name AS name, labels(n)[0] AS type, n.is_fraud_ring AS is_fraud_ring
    """)
    
    for record in nodes_result:
        node_id = record["id"] if record["id"] is not None else record["name"]
        if node_id is not None:
            node_type = record["type"].replace(PREFIX, "").lower() if record["type"] is not None else "unknown"
            is_fraud = record["is_fraud_ring"] if record["is_fraud_ring"] is not None else False
            G_for_embedding.add_node(node_id, name=record["name"], type=node_type, is_fraud_ring=is_fraud)
    
    # 获取所有关系（包括交易、归属和位置关系）
    edges_result = session.run(f"""
        MATCH (a)-[r:{PREFIX}TRANSFERS|{PREFIX}PAYS|{PREFIX}BELONGS_TO|{PREFIX}LOCATED_IN]->(b)
        RETURN a.id AS source_id, a.name AS source_name, 
               b.id AS target_id, b.name AS target_name, 
               type(r) AS relation, r.amount AS amount, r.is_fraud AS is_fraud
    """)
    
    for record in edges_result:
        source_id = record["source_id"] if record["source_id"] is not None else record["source_name"]
        target_id = record["target_id"] if record["target_id"] is not None else record["target_name"]
        
        if source_id is not None and target_id is not None:
            relation = record["relation"].replace(PREFIX, "").lower() if record["relation"] is not None else "unknown"
            is_fraud = record["is_fraud"] if record["is_fraud"] is not None else False
            amount = record["amount"] if record["amount"] is not None else 0.0
            
            # 欺诈交易的权重更高
            weight = 2.0 if is_fraud else 1.0
            G_for_embedding.add_edge(source_id, target_id, relation=relation, weight=weight, amount=amount, is_fraud=is_fraud)

# 转换为PyTorch Geometric数据格式
pyg_data = from_networkx(G_for_embedding)

# 定义Node2Vec模型
from torch_geometric.nn import Node2Vec
model = Node2Vec(
    pyg_data.edge_index,
    embedding_dim=128,
    walk_length=30,  # 增加游走长度
    context_size=10,
    walks_per_node=15,  # 增加每个节点的游走次数
    p=0.5,  # 返回参数 - 小于1时更倾向于BFS，有助于发现局部结构
    q=2.0,  # 外出参数 - 大于1时更倾向于DFS，有助于发现欺诈环
    num_negative_samples=1  # 负采样数量
)

# 训练嵌入
loader = model.loader(batch_size=64, shuffle=True)  # 减小批量大小
optimizer = torch.optim.Adam(model.parameters(), lr=0.005)  # 降低学习率
scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=3, gamma=0.5)  # 添加学习率调度器

# 增加训练轮次
print("\n训练Node2Vec图嵌入...")
for epoch in range(10):  # 增加训练轮次
    model.train()
    total_loss = 0
    for pos_rw, neg_rw in loader:
        optimizer.zero_grad()
        loss = model.loss(pos_rw, neg_rw)
        loss.backward()
        optimizer.step()
        total_loss += loss.item()
    scheduler.step()  # 更新学习率
    print(f"Epoch {epoch+1}: Loss {total_loss:.4f}, LR: {scheduler.get_last_lr()[0]:.6f}")

# 获取嵌入
model.eval()
embeddings = model(torch.arange(len(G_for_embedding)))

# === 3. PageRank识别中心节点（Neo4j版本）===
def get_high_risk_nodes():
    # 使用与create_graph相同的前缀
    # PREFIX = "FR_"  # Fraud Ring前缀
    
    with driver.session() as session:
        # 使用Neo4j的内置PageRank算法
        try:
            # 创建图投影，包含所有节点和关系类型
            session.run(f"""
                CALL gds.graph.project(
                    'fraudGraph',
                    ['{PREFIX}Account', '{PREFIX}Merchant', '{PREFIX}Bank', '{PREFIX}Region'],
                    ['{PREFIX}TRANSFERS', '{PREFIX}PAYS', '{PREFIX}BELONGS_TO', '{PREFIX}LOCATED_IN']
                )
            """)
            
            # 运行PageRank算法
            result = session.run("""
                CALL gds.pageRank.stream('fraudGraph')
                YIELD nodeId, score
                WITH gds.util.asNode(nodeId) AS node, score
                RETURN node.name AS name, node.type AS type, node.is_fraud_ring AS is_fraud_ring, score
                ORDER BY score DESC
                LIMIT 10
            """)
            
            # 获取结果
            high_risk_nodes = [(record["name"], record["type"], record["is_fraud_ring"], record["score"]) for record in result]
            
            # 删除投影图
            session.run("CALL gds.graph.drop('fraudGraph')")
            
            return high_risk_nodes
        except Exception as e:
            print(f"Neo4j PageRank执行失败: {e}")
            return None
</p>
        </div>
        <span id="typed"></span>
    </div>

    <!-- 可视化结果 -->
    <div class="plot">
        <h3>网络结构可视化（示例）</h3>
        <img src="fraud_ring_account.svg" alt="Network Graph" width="800">
    </div>
    <div class="plot">
        <h3>网络结构可视化（示例）</h3>
        <img src="fraud_ring_account_and_so.svg" alt="Network Graph" width="800">
    </div>

    <h3>代码说明：</h3>
    <ul>
        <li><strong>数据生成</strong>：模拟100个用户，10个设备（故意重复）和5个IP地址</li>
        <li><strong>图谱构建</strong>：使用NetworkX创建四维关系网络</li>
        <li><strong>PageRank分析</strong>：识别高频设备/IP（红色节点）</li>
        <li><strong>图嵌入</strong>：使用Node2Vec生成128维特征向量</li>
    </ul>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 从DOM元素中获取代码内容
            var codeContent = document.getElementById('typed-strings').innerText;
            // 将代码按行分割成数组
            var codeLines = codeContent.split('\n');
            
            // 创建一个累积内容的容器
            var terminalContent = document.createElement('div');
            document.querySelector('.terminal').appendChild(terminalContent);
            
            // 创建一个用于打字效果的容器，放在终端底部
            var typedContainer = document.createElement('div');
            document.querySelector('.terminal').appendChild(typedContainer);
            typedContainer.appendChild(document.getElementById('typed'));
            
            // 当前已显示的内容
            var currentContent = '';
            // 当前行索引
            var currentLineIndex = 0;
            
            // 创建一个新的Typed实例，只处理一行
            function typeNextLine() {
                if (currentLineIndex >= codeLines.length) {
                    console.log('打字效果完成');
                    return;
                }
                
                var typed = new Typed('#typed', {
                    strings: [codeLines[currentLineIndex]],
                    typeSpeed: 20,
                    showCursor: true,
                    cursorChar: '█',
                    loop: false,
                    onComplete: function(self) {
                        // 保存当前行内容
                        currentContent += codeLines[currentLineIndex] + '\n';
                        // 更新累积内容容器
                        terminalContent.innerHTML = currentContent;
                        // 移动到下一行
                        currentLineIndex++;
                        // 重置typed元素
                        document.getElementById('typed').innerHTML = '';
                        // 自动滚动到底部
                        document.querySelector('.terminal').scrollTop = document.querySelector('.terminal').scrollHeight;
                        // 继续下一行
                        setTimeout(typeNextLine, 100);
                    }
                });
            }
            
            // 开始打字效果
            typeNextLine();
        });
    </script>
</body>
</html>